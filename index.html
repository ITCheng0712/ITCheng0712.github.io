<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>CloudHao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="CloudHao">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="CloudHao">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="CloudHao" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CloudHao</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-大数据面经（2021-11月）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-12-23T02:08:09.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/">大数据面经（2021/11月）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1、Hadoop"><a href="#1、Hadoop" class="headerlink" title="1、Hadoop"></a>1、Hadoop</h2><h5 id="1、yarn原理"><a href="#1、yarn原理" class="headerlink" title="1、yarn原理"></a>1、yarn原理</h5><ul>
<li>yarn各个实例的概念<ul>
<li>ResourceManager：<br>ResourceManager是master上的进程，负责整个分布式系统的资源管理和调度。他会处理来自client端的请求（包括提交作业/杀死作业）；启动/监控Application Master；监控NodeManager的情况，比如可能挂掉的NodeManager。</li>
<li>NodeManager：<br>相对应的，NodeManager是处在slave节点上的进程，他只负责当前slave节点的资源管理和调度，以及task的运行。他会定期向ResourceManager回报资源/Container的情况（heartbeat）；接受来自ResourceManager对于Container的启停命令。</li>
<li> Application Master：<br>每一个提交到集群的作业都会有一个与之对应的Application Master来负责应用程序的管理。他负责进行数据切分；为当前应用程序向ResourceManager去申请资源（也就是Container），并分配给具体的任务；与NodeManager通信，用来启停具体的任务，任务运行在Container中；而任务的监控和容错也是由Application Master来负责的。</li>
<li>Container<br>那么container又是什么呢？它包含了Application Master向ResourceManager申请的计算资源，比如说CPU/内存的大小，以及任务运行所需的环境变量和队任务运行情况的描述。AM也是在container上运行的，不过AM的container是RM申请的。</li>
</ul>
</li>
<li>Yarn 的 Job 提交流程<ul>
<li>1.client向RM提交应用程序，其中包括启动该应用的ApplicationMaster的必须信息，例如ApplicationMaster程序、启动ApplicationMaster的命令、用户程序等</li>
<li>2.ResourceManager启动一个container用于运行ApplicationMaster</li>
<li>3.启动中的ApplicationMaster向ResourceManager注册自己，启动成功后与RM保持心跳</li>
<li>4.ApplicationMaster向ResourceManager发送请求,申请相应数目的container</li>
<li>5.申请成功的container，由ApplicationMaster进行初始化。container的启动信息初始化后，AM与对应的NodeManager通信，要求NM启动container</li>
<li>6.NM启动container</li>
<li>7.container运行期间，ApplicationMaster对container进行监控。container通过RPC协议向对应的AM汇报自己的进度和状态等信息</li>
<li>8.应用运行结束后，ApplicationMaster向ResourceManager注销自己，并允许属于它的container被收回</li>
</ul>
</li>
</ul>
<img src="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/Yarn%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B(%E8%AF%A6%E7%BB%86).png" class="">

<h5 id="2、mr原理"><a href="#2、mr原理" class="headerlink" title="2、mr原理"></a>2、mr原理</h5><img src="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/MR%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" class="">

<img src="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/MapReduce%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.png" class="">

<h6 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle:"></a>shuffle:</h6><ul>
<li>Map方法之后Reduce方法之前这段处理过程叫「Shuffle」</li>
<li>Map方法之后，数据首先进入到分区方法，把数据标记好分区，然后把数据发送到环形缓冲区；环形缓冲区默认大小100m，环形缓冲区达到80%时，进行溢写；溢写前对数据进行排序，排序按照对key的索引进行字典顺序排序，排序的手段「快排」；溢写产生大量溢写文件，需要对溢写文件进行「归并排序」；对溢写的文件也可以进行Combiner操作，前提是汇总操作，求平均值不行。最后将文件按照分区存储到磁盘，等待Reduce端拉取。</li>
<li>每个Reduce拉取Map端对应分区的数据。拉取数据后先存储到内存中，内存不够了，再存储到磁盘。拉取完所有数据后，采用归并排序将内存和磁盘中的数据都进行排序。在进入Reduce方法前，可以对数据进行分组操作。</li>
</ul>
<h5 id="3、hdfs中切片与块的区别"><a href="#3、hdfs中切片与块的区别" class="headerlink" title="3、hdfs中切片与块的区别"></a>3、hdfs中切片与块的区别</h5><ul>
<li>1.对比HDFS中数据的分块，块的大小默认为64M（或128M），同时产生了三个副本；<br>进行分片时先将块从分布式系统中取出，通过分片算法对块进行分片，片的单位就是块的大小（64M或128M）。</li>
<li>2.block是在物理内存上进行存储的，真实存在于hdfs上的。而片（split）是虚拟内存上的储存，是逻辑上的“分片”，减少块的数量，便于后续读取。</li>
<li>3.一个split只能属于一个文件，但是一个文件会被切成很多片。一个split可能包含多个block，但一个block不一定只属于一个split。</li>
</ul>
<h5 id="4、如何切片"><a href="#4、如何切片" class="headerlink" title="4、如何切片"></a>4、如何切片</h5><ul>
<li>总览：Hadoop的MapTask并行度和数据切片有关系，数据切片就是把输入的文件在逻辑上进行切片，对文件切成多少份，Hadoop就会分配多少个MapTask任务进行并行执行该文件。<br>Block与Splite区别：Block是HDFS物理上把数据分成一块一块；数据切片只是在逻辑上对输入进行分片，并不会在磁盘上将其切分成片进行存储。比如一个512MB的文件在HDFS上存储，默认一个Block为128MB，那么需要4个block进行物理存储，但是如果对该文件进行切片，且每个分片100MB，那么会需要5个MapTask来执行任务。当然正常情况下不会这样做，一般逻辑切片的大小和HDFS的block大小是一致的。</li>
<li>切片的不同机制：<ul>
<li>TextInputFormat切片机制：<br>切片方式：TextInputFormat是默认的切片机制，按文件规划进行切分。比如切片默认为128M，如果一个文件为200M，则会形成两个切片，一个是128M，一个是72M，启动两个MapTask任务进行处理任务。但是如果一个文件只有1M，也会单独启动一个MapTask执行此任务，如果是10个这样的小文件，就会启动10个MapTask处理小文件任务。<br>读取方式：TextInputFormat是按行读取文件的每条记录，key代表读取的文件行在该文件中的起始字节偏移量，key为LongWritable类型；value为读取的行内容，不包括任何行终止符（换行符/回车符）, value为Text类型，相当于java中的String类型。</li>
<li>CombineTextInputFormat切片机制：<br>处理小文件过多的场景<br>虚拟存储过程:<br>将输入目录下所有文件大小，依次和设置的setMaxInputSplitSize值比较，如果不大于设置的最大值，逻辑上划分一个块。如果输入文件大于设置的最大值且大于两倍，那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值2倍，此时将文件均分成2个虚拟存储块（防止出现太小切片）。<br>例如setMaxInputSplitSize值为4M，输入文件大小为8.02M，则先逻辑上分成一个4M。剩余的大小为4.02M，如果按照4M逻辑划分，就会出现0.02M的小的虚拟存储文件，所以将剩余的4.02M文件切分成（2.01M和2.01M）两个文件。<br>切片过程:<br>判断虚拟存储的文件大小是否大于setMaxInputSplitSize值，大于等于则单独形成一个切片；<br>如果不大于则跟下一个虚拟存储文件进行合并，共同形成一个切片。<br>源码解析: <a target="_blank" rel="noopener" href="https://blog.csdn.net/u010010428/article/details/51469994">https://blog.csdn.net/u010010428/article/details/51469994</a></li>
</ul>
</li>
</ul>
<h2 id="2、hive"><a href="#2、hive" class="headerlink" title="2、hive"></a>2、hive</h2><h5 id="1、udf函数创建、使用步骤，项目中写过udf吗，实现的功能是什么"><a href="#1、udf函数创建、使用步骤，项目中写过udf吗，实现的功能是什么" class="headerlink" title="1、udf函数创建、使用步骤，项目中写过udf吗，实现的功能是什么"></a>1、udf函数创建、使用步骤，项目中写过udf吗，实现的功能是什么</h5><ul>
<li>创建步骤：<ul>
<li>1.新建maven工程，导入需要使用的包。</li>
<li>2.新建一个类继承UDF类并重写evaluate方法。</li>
<li>3.打包编译生成jar包。</li>
<li>4.注册UDF函数：<br>临时生效，即只在当前hive shell环境生效<br><code>hive&gt; add jar hive-1.0.jar; #加入jar包，注意jar包的路径，这里是当前路径</code><br>永久有效，可以在多hive shell回话窗口使用udf函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put hive-1.0.jar hdfs://nameservice-ha/udf/ #上传jar版至HDFS，路径可以自定义</span><br><span class="line">hive&gt; CREATE FUNCTION addhello AS  &#x27;com.mycompany.bda.UdfHello&#x27; USING JAR &#x27;hdfs://nameservice-ha/udf/hive-1.0.jar&#x27;;</span><br></pre></td></tr></table></figure>
针对华为MRS：<br>可以直接放到master节点的/opt/Bigdata/third_lib/Hive目录下。</li>
</ul>
</li>
</ul>
<h5 id="2、什么时候或场景使用窗口函数"><a href="#2、什么时候或场景使用窗口函数" class="headerlink" title="2、什么时候或场景使用窗口函数"></a>2、什么时候或场景使用窗口函数</h5><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Rank()</td>
<td align="left">返回数据项在分组中的排名，排名相等会在名次中留下空位</td>
</tr>
<tr>
<td align="left">DENSE_RANK()</td>
<td align="left">返回数据项在分组中的排名，排名相等会在名次中不会留下空位</td>
</tr>
<tr>
<td align="left">NTILE()</td>
<td align="left">返回n分片后的值</td>
</tr>
<tr>
<td align="left">ROW_NUMBER()</td>
<td align="left">为每条记录返回一个数字</td>
</tr>
</tbody></table>
<ul>
<li>用于分区排序<ul>
<li>ROW_NUMBER() OVER函数的基本用法<br>语法：ROW_NUMBER() OVER(PARTITION BY COLUMNORDER BY COLUMN)<br>详解：<br>row_number() OVER (PARTITION BY COL1 ORDERBY COL2)表示根据COL1分组，在分组内部根据COL2排序，而此函数计算的值就表示每组内部排序后的顺序编号（该编号在组内是连续并且唯一的)。</li>
</ul>
</li>
<li>动态Group By<ul>
<li>可以在distinct()函数进行去重执行速度慢时，代替distinct()进行去重操作。 </li>
</ul>
</li>
<li>Top N<ul>
<li>Rank()和ROW_NUMBER()等合用，具体看业务需求。</li>
</ul>
</li>
<li>累计计算<ul>
<li>sum() over()</li>
</ul>
</li>
<li>层次查询<ul>
<li>NTILE()</li>
</ul>
</li>
</ul>
<h5 id="3、说下hive是怎么调优的（数据倾斜、谓词下推、预聚合等）"><a href="#3、说下hive是怎么调优的（数据倾斜、谓词下推、预聚合等）" class="headerlink" title="3、说下hive是怎么调优的（数据倾斜、谓词下推、预聚合等）"></a>3、说下hive是怎么调优的（数据倾斜、谓词下推、预聚合等）</h5><ul>
<li>数据倾斜调优：<ul>
<li>1.针对goupby出现数据倾斜：加盐处理</li>
<li>2.针对join出现的数据倾斜：<br>  抽样求出引起数据倾斜的key值，进行过滤处理。<br>  优先使用mapjoin。</li>
<li>3.大小表join：使用mapjoin，将小表放在前面进行join操作。</li>
<li>4.谓词下推</li>
<li>5.预聚合<br>…….</li>
</ul>
</li>
</ul>
<h2 id="3、Hbase"><a href="#3、Hbase" class="headerlink" title="3、Hbase"></a>3、Hbase</h2><h5 id="1、HBASE架构"><a href="#1、HBASE架构" class="headerlink" title="1、HBASE架构"></a>1、HBASE架构</h5><img src="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/Hbase%E7%BB%84%E4%BB%B6%E4%BF%A1%E6%81%AF.png" class="" title="Hbase组件信息图">

<img src="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/Hbase%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="Hbase架构图">

<ul>
<li>Hbase读流程：<ul>
<li>(1) Client访问Zookeeper，查找-ROOT-表，获取.META.表信息。</li>
<li>(2) 从.META.表查找，获取存放目标数据的Region信息，从而找到对应的RegionServer。</li>
<li>(3) 通过RegionServer获取需要查找的数据。</li>
<li>(4) Regionserver的内存分为MemStore和BlockCache两部分，MemStore主要用于写数据，BlockCache主要用于读数据。读请求先到MemStore中查数据，查不到就到BlockCache中查，再查不到就会到StoreFile上读，并把读的结果放入BlockCache。</li>
</ul>
</li>
<li>Hbase写流程：<ul>
<li>(1) Client通过Zookeeper的调度，向RegionServer发出写数据请求，在Region中写数据。</li>
<li>(2) 数据被写入Region的MemStore，直到MemStore达到预设阈值。</li>
<li>(3) MemStore中的数据被Flush成一个StoreFile。</li>
<li>(4) 随着StoreFile文件的不断增多，当其数量增长到一定阈值后，触发Compact合并操作，将多个StoreFile合并成一个StoreFile，同时进行版本合并和数据删除。</li>
<li>(5) StoreFiles通过不断的Compact合并操作，逐步形成越来越大的StoreFile。</li>
<li>(6) 单个StoreFile大小超过一定阈值后，触发Split操作，把当前Region Split成2个新的Region。父Region会下线，新Split出的2个子Region会被HMaster分配到相应的RegionServer上，使得原先1个Region的压力得以分流到2个Region上。</li>
</ul>
</li>
</ul>
<h5 id="2、生产中Hbase你是如何调优的"><a href="#2、生产中Hbase你是如何调优的" class="headerlink" title="2、生产中Hbase你是如何调优的"></a>2、生产中Hbase你是如何调优的</h5><ul>
<li>1.JVM调优：根据集群现状和Region总数调整HMaster的JVM内存大小。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangshuminjava/article/details/80532784">https://blog.csdn.net/wangshuminjava/article/details/80532784</a></li>
</ul>
<h5 id="3、HBASE中建表语句中有个blocksize参数，这个值设置的多少（cdh平台默认64kb），这个值的大小对HBASE有什么影响"><a href="#3、HBASE中建表语句中有个blocksize参数，这个值设置的多少（cdh平台默认64kb），这个值的大小对HBASE有什么影响" class="headerlink" title="3、HBASE中建表语句中有个blocksize参数，这个值设置的多少（cdh平台默认64kb），这个值的大小对HBASE有什么影响"></a>3、HBASE中建表语句中有个blocksize参数，这个值设置的多少（cdh平台默认64kb），这个值的大小对HBASE有什么影响</h5><ul>
<li>blocksize：设置HFile数据块大小(默认64kb),HFile会被切割成多个大小相等的block块儿(这里的block块儿和HDFS中的不是一个。)大的Block有利于顺序Scan，小号Block利于随机查询。正常情况下使用默认即可，有特殊业务需求是可以私有化定制。</li>
</ul>
<h5 id="4、你们HBASE集群有预分区吗，怎么设置的，为什么这么设置"><a href="#4、你们HBASE集群有预分区吗，怎么设置的，为什么这么设置" class="headerlink" title="4、你们HBASE集群有预分区吗，怎么设置的，为什么这么设置"></a>4、你们HBASE集群有预分区吗，怎么设置的，为什么这么设置</h5><ul>
<li>1.shell createTable直接创建预分区。</li>
<li>2.通过文件创建。</li>
<li>3.javaAPI createTable并预分区。</li>
</ul>
<h5 id="5、有出现热点问题吗，怎么避免"><a href="#5、有出现热点问题吗，怎么避免" class="headerlink" title="5、有出现热点问题吗，怎么避免"></a>5、有出现热点问题吗，怎么避免</h5><ul>
<li>1.预分区+合理的rowkey设计</li>
<li>2.布隆过滤器，协处理器(了解不多，有兴趣可以到官网查的看一下)</li>
</ul>
<h2 id="4、spark"><a href="#4、spark" class="headerlink" title="4、spark"></a>4、spark</h2><h5 id="1、spark提交命令、参数"><a href="#1、spark提交命令、参数" class="headerlink" title="1、spark提交命令、参数"></a>1、spark提交命令、参数</h5><p>./bin/spark-submit –help</p>
<p>./bin/spark-submit <br>  –class <main-class> <br>  –master <master-url> <br>  –deploy-mode <deploy-mode> <br>  –conf <key>=<value> <br>  … # other options<br>  <application-jar> \</p>
<ul>
<li>常用参数:<ul>
<li>–queue:指定任务运行队列</li>
<li>–executor-cores:指定任务CPU</li>
<li>–executor-memory:指定任务运行内存</li>
</ul>
</li>
</ul>
<h2 id="5、flink"><a href="#5、flink" class="headerlink" title="5、flink"></a>5、flink</h2><h5 id="1、flink中watermark是什么"><a href="#1、flink中watermark是什么" class="headerlink" title="1、flink中watermark是什么"></a>1、flink中watermark是什么</h5><h5 id="2、简单说下checkpoint机制，你项目中checkpoint间隔设置的多少，为什么取这个间隔数"><a href="#2、简单说下checkpoint机制，你项目中checkpoint间隔设置的多少，为什么取这个间隔数" class="headerlink" title="2、简单说下checkpoint机制，你项目中checkpoint间隔设置的多少，为什么取这个间隔数"></a>2、简单说下checkpoint机制，你项目中checkpoint间隔设置的多少，为什么取这个间隔数</h5><ul>
<li>1.简单来说checkpoint就是一个检查点，属于Flink的一个容错机制，可以在由于某些特殊情况导致Flink任务挂掉时，用来进行任务恢复。</li>
<li>2.公司这边是120秒一个checkpoint，俩个checkpoint之间最小间隔60秒，checkpoint的过期时间是30分钟。</li>
<li>3.尽量保证实时数据正确，但是由于数据俩份，即使看板中当天Flink任务有问题，也可通过离线数据补回。</li>
</ul>
<h5 id="3、项目中用到窗口函数了吗，简单的说下窗口函数"><a href="#3、项目中用到窗口函数了吗，简单的说下窗口函数" class="headerlink" title="3、项目中用到窗口函数了吗，简单的说下窗口函数"></a>3、项目中用到窗口函数了吗，简单的说下窗口函数</h5><h2 id="6、kafka"><a href="#6、kafka" class="headerlink" title="6、kafka"></a>6、kafka</h2><h5 id="1、kafka创建topic命令（kafka命令类的问题没必要刻意记命令，直接回怼说平时命令存在自己常用的记事本中，直接复制粘贴）"><a href="#1、kafka创建topic命令（kafka命令类的问题没必要刻意记命令，直接回怼说平时命令存在自己常用的记事本中，直接复制粘贴）" class="headerlink" title="1、kafka创建topic命令（kafka命令类的问题没必要刻意记命令，直接回怼说平时命令存在自己常用的记事本中，直接复制粘贴）"></a>1、kafka创建topic命令（kafka命令类的问题没必要刻意记命令，直接回怼说平时命令存在自己常用的记事本中，直接复制粘贴）</h5><ul>
<li>1.bin/kafka-topic.sh –zookeeper host:2181 –create </li>
</ul>
<h5 id="2、kafka多少个节点，副本怎么设置的"><a href="#2、kafka多少个节点，副本怎么设置的" class="headerlink" title="2、kafka多少个节点，副本怎么设置的"></a>2、kafka多少个节点，副本怎么设置的</h5><ul>
<li>2.3节点8核64G，正常topic8分区俩副本。有需求时，比如有直播活动导致业务量激增，有扩容至5节点，16个分区。压测时可以到8万qps每秒。</li>
</ul>
<h5 id="3、kafka消费慢遇到过吗，有没有什么排查和解决思路"><a href="#3、kafka消费慢遇到过吗，有没有什么排查和解决思路" class="headerlink" title="3、kafka消费慢遇到过吗，有没有什么排查和解决思路"></a>3、kafka消费慢遇到过吗，有没有什么排查和解决思路</h5><ul>
<li>kafka消费慢、存在堆积的可能原因：<ul>
<li>1.业务代码有更新，代码上线后导致的。</li>
<li>2.重复消费问题。</li>
</ul>
</li>
</ul>
<h2 id="7、语言（Java、Python、Scala、C、go等）"><a href="#7、语言（Java、Python、Scala、C、go等）" class="headerlink" title="7、语言（Java、Python、Scala、C、go等）"></a>7、语言（Java、Python、Scala、C、go等）</h2><p>java：</p>
<ul>
<li>1.基础：<ul>
<li>1.8大基本数据类型。(int,double,float,long,char,string,boolean,byte,short。String不算基本数据类型，但是常用。)</li>
<li>2.修饰符：<ul>
<li>访问控制修饰符：<br>public(常用)<br>protected<br>default<br>private(常用)</li>
<li>非访问控制修饰符：<br>static、final、class、abstarct等。<br>还是看菜鸟教程吧：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-operators.html">https://www.runoob.com/java/java-operators.html</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8、shell"><a href="#8、shell" class="headerlink" title="8、shell"></a>8、shell</h2><p>菜鸟教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-shell-process-control.html">https://www.runoob.com/linux/linux-shell-process-control.html</a></p>
<h2 id="9、开放性问题及其他"><a href="#9、开放性问题及其他" class="headerlink" title="9、开放性问题及其他"></a>9、开放性问题及其他</h2><h5 id="1、简单的说下你最近的一个项目"><a href="#1、简单的说下你最近的一个项目" class="headerlink" title="1、简单的说下你最近的一个项目"></a>1、简单的说下你最近的一个项目</h5><h5 id="2、你对数据中台的理解（参考：为什么建数据中台、解决的问题是什么、和数仓或实时流分析的区别在哪）"><a href="#2、你对数据中台的理解（参考：为什么建数据中台、解决的问题是什么、和数仓或实时流分析的区别在哪）" class="headerlink" title="2、你对数据中台的理解（参考：为什么建数据中台、解决的问题是什么、和数仓或实时流分析的区别在哪）"></a>2、你对数据中台的理解（参考：为什么建数据中台、解决的问题是什么、和数仓或实时流分析的区别在哪）</h5><h5 id="3、某某行业（如保险行业）中使用的架构、存在的问题、痛点、如何解决"><a href="#3、某某行业（如保险行业）中使用的架构、存在的问题、痛点、如何解决" class="headerlink" title="3、某某行业（如保险行业）中使用的架构、存在的问题、痛点、如何解决"></a>3、某某行业（如保险行业）中使用的架构、存在的问题、痛点、如何解决</h5><h5 id="4、说下工作中遇到的问题（从问题现象、排查思路、解决过程，结果验证来答）"><a href="#4、说下工作中遇到的问题（从问题现象、排查思路、解决过程，结果验证来答）" class="headerlink" title="4、说下工作中遇到的问题（从问题现象、排查思路、解决过程，结果验证来答）"></a>4、说下工作中遇到的问题（从问题现象、排查思路、解决过程，结果验证来答）</h5><h5 id="5、大厂会问：哪个组件你比较熟悉，然后会根据你熟悉的组件往深了怼你"><a href="#5、大厂会问：哪个组件你比较熟悉，然后会根据你熟悉的组件往深了怼你" class="headerlink" title="5、大厂会问：哪个组件你比较熟悉，然后会根据你熟悉的组件往深了怼你"></a>5、大厂会问：哪个组件你比较熟悉，然后会根据你熟悉的组件往深了怼你</h5><h5 id="6、手撕常见算法（面大厂自有-BAT、京东、美团等-的都会问，外包可能不涉及）"><a href="#6、手撕常见算法（面大厂自有-BAT、京东、美团等-的都会问，外包可能不涉及）" class="headerlink" title="6、手撕常见算法（面大厂自有(BAT、京东、美团等)的都会问，外包可能不涉及）"></a>6、手撕常见算法（面大厂自有(BAT、京东、美团等)的都会问，外包可能不涉及）</h5><h5 id="7、项目是如何技术选型的"><a href="#7、项目是如何技术选型的" class="headerlink" title="7、项目是如何技术选型的"></a>7、项目是如何技术选型的</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/" data-id="ckxprkvpz0004fksof4fw1arz" data-title="大数据面经（2021/11月）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hadoop面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-12-20T06:33:33.000Z" itemprop="datePublished">2021-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/">hadoop面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-什么是Hadoop？"><a href="#1-什么是Hadoop？" class="headerlink" title="1.什么是Hadoop？"></a>1.什么是Hadoop？</h2><p>HDFS+Yarn+MapReduce，对大量数据进行分布式处理的软件框架。以一种可靠、高效、可伸缩的方式进行数据处理。<br>广义上指一个生态圈，泛指大数据技术相关的开源产品。</p>
<h2 id="2-Hadoop和Spark的差异"><a href="#2-Hadoop和Spark的差异" class="headerlink" title="2.Hadoop和Spark的差异"></a>2.Hadoop和Spark的差异</h2><table>
<thead>
<tr>
<th>-</th>
<th align="left">Hadoop</th>
<th align="left">Spark</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td align="left">基础平台，包含存储、计算、调度</td>
<td align="left">分布式计算框架</td>
</tr>
<tr>
<td>场景</td>
<td align="left">大规模数据集上的批处理</td>
<td align="left">迭代计算、交互式计算、流计算</td>
</tr>
<tr>
<td>价格</td>
<td align="left">对机器要求低</td>
<td align="left">对内存有要求</td>
</tr>
<tr>
<td>编程范式</td>
<td align="left">MapReduce，API 较为底层，算法适应性差</td>
<td align="left">RDD组成DAG有向无环图，API较为顶层，方便使用</td>
</tr>
<tr>
<td>数据存储结构</td>
<td align="left">MapReduce计算的中间结果存储在HDFS磁盘上，延迟高</td>
<td align="left">RDD结果存储在内存中，延迟低</td>
</tr>
<tr>
<td>运行方式</td>
<td align="left">Task以进程方式维护，任务启动慢</td>
<td align="left">Task以线程方式维护，任务启动快</td>
</tr>
</tbody></table>
<h2 id="3-Hadoop常见的版本有哪些？"><a href="#3-Hadoop常见的版本有哪些？" class="headerlink" title="3.Hadoop常见的版本有哪些？"></a>3.Hadoop常见的版本有哪些？</h2><p>CDH：有可用的开源免费包，但是本身不在开源、免费，易维护但扩展性差。<br>Apache：完全开源、免费，不易维护。<br>Hortonworks：有可用的HDP包，但是本身不在免费，易维护但扩展性差。</p>
<h2 id="4-简单介绍Hadoop1-0，2-0，3-0的区别"><a href="#4-简单介绍Hadoop1-0，2-0，3-0的区别" class="headerlink" title="4.简单介绍Hadoop1.0，2.0，3.0的区别"></a>4.简单介绍Hadoop1.0，2.0，3.0的区别</h2><h5 id="Hadoop1-0："><a href="#Hadoop1-0：" class="headerlink" title="Hadoop1.0："></a>Hadoop1.0：</h5><ul>
<li>由HDFS和MapReduce构成，HDFS由一个NameNode和多个DataNode组成，MapReduce由一个JobTracker和多个TaskTracker组成。Hadoop1.0易发生单点故障，拓展性差，性能低。</li>
</ul>
<h5 id="Hadoop2-0，为克服1-0中不足，提出了："><a href="#Hadoop2-0，为克服1-0中不足，提出了：" class="headerlink" title="Hadoop2.0，为克服1.0中不足，提出了："></a>Hadoop2.0，为克服1.0中不足，提出了：</h5><ul>
<li>Yarn，彻底代替了1.0中的JobTracker，在MRv1 中的 JobTracker 资源管理和作业跟踪的功能被抽象为 ResourceManager 和 AppMaster 两个组件。Yarn 还支持多种应用程序和框架，提供统一的资源调度和管理功能。</li>
<li>NameNode故障得以解决，在Hadoop2.2.0之后提供了主备NameNode方案，并支持 NFS，QJM 和 Zookeeper 三种可选的共享存储系统。</li>
<li>HDFS 快照，指 HDFS（或子系统）在某一时刻的只读镜像。(实战操作：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/JackQ/p/4586663.html">https://www.cnblogs.com/JackQ/p/4586663.html</a>)</li>
<li>支持Windows 操作系统。</li>
<li>Append，新版本的 Hadoop 引入了对文件的追加操作。</li>
</ul>
<h5 id="相比于Hadoop2-0，Hadoop3-0-是直接基于-JDK1-8-发布的一个新版本，同时，Hadoop3-0引入了一些重要的功能和特性："><a href="#相比于Hadoop2-0，Hadoop3-0-是直接基于-JDK1-8-发布的一个新版本，同时，Hadoop3-0引入了一些重要的功能和特性：" class="headerlink" title="相比于Hadoop2.0，Hadoop3.0 是直接基于 JDK1.8 发布的一个新版本，同时，Hadoop3.0引入了一些重要的功能和特性："></a>相比于Hadoop2.0，Hadoop3.0 是直接基于 JDK1.8 发布的一个新版本，同时，Hadoop3.0引入了一些重要的功能和特性：</h5><ul>
<li>HDFS可擦除编码：这项技术使HDFS在不降低可靠性的前提下节省了很大一部分存储空间</li>
<li>多NameNode支持：在Hadoop3.0中，新增了对多NameNode的支持。当然，处于Active状态的NameNode实例必须只有一个。也就是说，从Hadoop3.0开始，在同一个集群中，支持一个 ActiveNameNode 和 多个 StandbyNameNode 的部署方式。</li>
<li>MR Native Task优化</li>
<li>Yarn基于cgroup 的内存和磁盘 I/O 隔离</li>
<li>Yarn container resizing</li>
</ul>
<h2 id="5-Hadoop常用的端口号"><a href="#5-Hadoop常用的端口号" class="headerlink" title="5.Hadoop常用的端口号"></a>5.Hadoop常用的端口号</h2><ul>
<li>NameNode(dfs.namenode.http-address):50070,http服务的端口</li>
<li>NameNode(fs.defaultFS):8020,接收Client连接的RPC端口，用于获取文件系统metadata信息</li>
<li>Yarn webUI:8088</li>
<li>DataNode(dfs.datanode.address datanode):50010,服务端口，用于数据传输</li>
<li>DataNode(dfs.datanode.http.address):50075,http服务的端口</li>
<li>ZKFC(dfs.ha.zkfc.port):8019,ZooKeeper FailoverController，用于NN HA</li>
</ul>
<h2 id="6-简单介绍一下搭建Hadoop集群的流程"><a href="#6-简单介绍一下搭建Hadoop集群的流程" class="headerlink" title="6.简单介绍一下搭建Hadoop集群的流程"></a>6.简单介绍一下搭建Hadoop集群的流程</h2><p>linux基础准备：</p>
<ul>
<li>1.主机名修改，hosts配置。</li>
<li>2.免密配置</li>
<li>3.关闭防火墙</li>
<li>4.关闭selinux</li>
<li>5.JDK安装<br>搭建工作：</li>
<li>1.上传包</li>
<li>2.配置hadoop配置文件，包括hdfs-site.xml，yarn-site.xml等。</li>
<li>3.格式化NameNode。</li>
<li>4.启动。</li>
</ul>
<h2 id="7-介绍一下HDFS读写流程"><a href="#7-介绍一下HDFS读写流程" class="headerlink" title="7.介绍一下HDFS读写流程"></a>7.介绍一下HDFS读写流程</h2><h3 id="HDFS读流程："><a href="#HDFS读流程：" class="headerlink" title="HDFS读流程："></a>HDFS读流程：</h3><img src="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/HDFS%E8%AF%BB%E6%B5%81%E7%A8%8B.png" class="" title="读流程图">

<h3 id="HDFS写流程："><a href="#HDFS写流程：" class="headerlink" title="HDFS写流程："></a>HDFS写流程：</h3><img src="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/HDFS%E5%86%99%E6%B5%81%E7%A8%8B.png" class="" title="写流程图">


<h2 id="8-介绍一下MapReduce的Shuffle过程，并给出Hadoop优化的方案"><a href="#8-介绍一下MapReduce的Shuffle过程，并给出Hadoop优化的方案" class="headerlink" title="8.介绍一下MapReduce的Shuffle过程，并给出Hadoop优化的方案"></a>8.介绍一下MapReduce的Shuffle过程，并给出Hadoop优化的方案</h2><img src="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/MapReduce%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.png" class="" title="MapReduce计算流程图">

<h5 id="shuffle："><a href="#shuffle：" class="headerlink" title="shuffle："></a>shuffle：</h5><ul>
<li>Map方法之后Reduce方法之前这段处理过程叫「Shuffle」</li>
<li>Map方法之后，数据首先进入到分区方法，把数据标记好分区，然后把数据发送到环形缓冲区；环形缓冲区默认大小100m，环形缓冲区达到80%时，进行溢写；溢写前对数据进行排序，排序按照对key的索引进行字典顺序排序，排序的手段「快排」；溢写产生大量溢写文件，需要对溢写文件进行「归并排序」；对溢写的文件也可以进行Combiner操作，前提是汇总操作，求平均值不行。最后将文件按照分区存储到磁盘，等待Reduce端拉取。</li>
<li>每个Reduce拉取Map端对应分区的数据。拉取数据后先存储到内存中，内存不够了，再存储到磁盘。拉取完所有数据后，采用归并排序将内存和磁盘中的数据都进行排序。在进入Reduce方法前，可以对数据进行分组操作。</li>
</ul>
<h3 id="hadoop优化方案："><a href="#hadoop优化方案：" class="headerlink" title="hadoop优化方案："></a>hadoop优化方案：</h3><h5 id="1-HDFS小文件影响"><a href="#1-HDFS小文件影响" class="headerlink" title="1.HDFS小文件影响"></a>1.HDFS小文件影响</h5><ul>
<li>影响NameNode的寿命，因为文件元数据存储在NameNode的内存中</li>
<li>影响计算引擎的任务数量，比如每个小的文件都会生成一个Map任务</li>
</ul>
<h5 id="2-数据输入小文件处理"><a href="#2-数据输入小文件处理" class="headerlink" title="2.数据输入小文件处理"></a>2.数据输入小文件处理</h5><ul>
<li>合并小文件：对小文件进行归档（Har）、自定义Inputformat将小文件存储成SequenceFile文件。</li>
<li>采用ConbinFileInputFormat来作为输入，解决输入端大量小文件场景</li>
<li>对于大量小文件Job，可以开启JVM重用</li>
</ul>
<h5 id="3-Map阶段"><a href="#3-Map阶段" class="headerlink" title="3.Map阶段"></a>3.Map阶段</h5><ul>
<li>增大环形缓冲区大小。由100m扩大到200m</li>
<li>增大环形缓冲区溢写的比例。由80%扩大到90%</li>
<li>减少对溢写文件的merge次数。（10个文件，一次20个merge）</li>
<li>不影响实际业务的前提下，采用Combiner提前合并，减少 I/O</li>
</ul>
<h5 id="4-Reduce阶段"><a href="#4-Reduce阶段" class="headerlink" title="4.Reduce阶段"></a>4.Reduce阶段</h5><ul>
<li>合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致 Map、Reduce任务间竞争资源，造成处理超时等错误。</li>
<li>设置Map、Reduce共存：调整 slowstart.completedmaps 参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间</li>
<li>规避使用Reduce，因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。</li>
<li>增加每个Reduce去Map中拿数据的并行数</li>
<li>集群性能可以的前提下，增大Reduce端存储数据内存的大小</li>
</ul>
<h5 id="5-IO传输"><a href="#5-IO传输" class="headerlink" title="5.IO传输"></a>5.IO传输</h5><ul>
<li>采用数据压缩的方式，减少网络IO的的时间</li>
<li>使用SequenceFile二进制文件</li>
</ul>
<h5 id="6-参数调优"><a href="#6-参数调优" class="headerlink" title="6.参数调优"></a>6.参数调优</h5><ul>
<li>MapTask默认内存大小为1G，可以增加MapTask内存大小为4</li>
<li>ReduceTask默认内存大小为1G，可以增加ReduceTask内存大小为4-5g</li>
<li>可以增加MapTask的cpu核数，增加ReduceTask的CPU核数</li>
<li>增加每个Container的CPU核数和内存大小</li>
<li>调整每个Map Task和Reduce Task最大重试次数</li>
</ul>
<h5 id="7-压缩"><a href="#7-压缩" class="headerlink" title="7.压缩"></a>7.压缩</h5><img src="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8E%8B%E7%BC%A9.png" class="">
<p>如果面试过程问起，我们一般回答压缩方式为Snappy，特点速度快，缺点无法切分（可以回答在链式MR中，Reduce端输出使用bzip2压缩，以便后续的map任务对数据进行split）</p>
<h2 id="9-介绍一下-Yarn-的-Job-提交流程"><a href="#9-介绍一下-Yarn-的-Job-提交流程" class="headerlink" title="9.介绍一下 Yarn 的 Job 提交流程"></a>9.介绍一下 Yarn 的 Job 提交流程</h2><h5 id="详细流程："><a href="#详细流程：" class="headerlink" title="详细流程："></a>详细流程：</h5><img src="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/Yarn%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B(%E8%AF%A6%E7%BB%86).png" class="">

<h5 id="简略流程："><a href="#简略流程：" class="headerlink" title="简略流程："></a>简略流程：</h5><img src="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/Yarn%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B(%E7%AE%80%E7%95%A5).png" class="">

<ul>
<li>1.client向RM提交应用程序，其中包括启动该应用的ApplicationMaster的必须信息，例如ApplicationMaster程序、启动ApplicationMaster的命令、用户程序等</li>
<li>2.ResourceManager启动一个container用于运行ApplicationMaster</li>
<li>3.启动中的ApplicationMaster向ResourceManager注册自己，启动成功后与RM保持心跳</li>
<li>4.ApplicationMaster向ResourceManager发送请求,申请相应数目的container</li>
<li>5.申请成功的container，由ApplicationMaster进行初始化。container的启动信息初始化后，AM与对应的NodeManager通信，要求NM启动container</li>
<li>6.NM启动container</li>
<li>7.container运行期间，ApplicationMaster对container进行监控。container通过RPC协议向对应的AM汇报自己的进度和状态等信息</li>
<li>8.应用运行结束后，ApplicationMaster向ResourceManager注销自己，并允许属于它的container被收回</li>
</ul>
<h2 id="10-介绍下Yarn默认的调度器，调度器分类，以及它们之间的区别"><a href="#10-介绍下Yarn默认的调度器，调度器分类，以及它们之间的区别" class="headerlink" title="10.介绍下Yarn默认的调度器，调度器分类，以及它们之间的区别"></a>10.介绍下Yarn默认的调度器，调度器分类，以及它们之间的区别</h2><h5 id="Hadoop调度器主要分为三类："><a href="#Hadoop调度器主要分为三类：" class="headerlink" title="Hadoop调度器主要分为三类："></a>Hadoop调度器主要分为三类：</h5><ul>
<li>1.FIFO Scheduler：先进先出调度器：优先提交的，优先执行，后面提交的等待【生产环境不会使用】</li>
<li>2.Capacity Scheduler：容量调度器：允许看创建多个任务对列，多个任务对列可以同时执行。但是一个队列内部还是先进先出。【Hadoop2.7.2默认的调度器】</li>
<li>Fair Scheduler：公平调度器：第一个程序在启动时可以占用其他队列的资源（100%占用），当其他队列有任务提交时，占用资源的队列需要将资源还给该任务。还资源的时候，效率比较慢。【CDH版本的yarn调度器默认】</li>
</ul>
<h2 id="11-了解过哪些Hadoop的参数优化"><a href="#11-了解过哪些Hadoop的参数优化" class="headerlink" title="11.了解过哪些Hadoop的参数优化"></a>11.了解过哪些Hadoop的参数优化</h2><ul>
<li>在hdfs-site.xml文件中配置多目录，最好提前配置好，否则更改目录需要重新启动集群</li>
<li>NameNode有一个工作线程池，用来处理不同DataNode的并发心跳以及客户端并发的元数据操作 (dfs.namenode.handler.count=20 * log2(Cluster Size))</li>
<li>编辑日志存储路径dfs.namenode.edits.dir设置与镜像文件存储路径dfs.namenode.name.dir尽量分开，达到最低写入延迟</li>
<li>服务器节点上YARN可使用的物理内存总量，默认是8192（MB），注意，如果你的节点内存资源不够8GB，则需要调减小这个值，而YARN不会智能的探测节点的物理内存总量</li>
<li>单个任务可申请的最多物理内存量，默认是8192（MB）</li>
</ul>
<h2 id="12-了解过Hadoop的基准测试吗"><a href="#12-了解过Hadoop的基准测试吗" class="headerlink" title="12.了解过Hadoop的基准测试吗?"></a>12.了解过Hadoop的基准测试吗?</h2><p>搭建完Hadoop集群后需要对HDFS读写性能和MR计算能力测试。测试jar包在hadoop的share文件夹下。</p>
<h2 id="13-你是怎么处理Hadoop宕机的问题的"><a href="#13-你是怎么处理Hadoop宕机的问题的" class="headerlink" title="13.你是怎么处理Hadoop宕机的问题的?"></a>13.你是怎么处理Hadoop宕机的问题的?</h2><ul>
<li>如果MR造成系统宕机。此时要控制Yarn同时运行的任务数，和每个任务申请的最大内存。调整参数：yarn.scheduler.maximum-allocation-mb（单个任务可申请的最多物理内存量，默认是8192MB）。</li>
<li>如果写入文件过量造成NameNode宕机。那么调高Kafka的存储大小，控制从Kafka到HDFS的写入速度。高峰期的时候用Kafka进行缓存，高峰期过去数据同步会自动跟上。</li>
</ul>
<h2 id="14-你是如何解决Hadoop数据倾斜的问题的，能举个例子吗"><a href="#14-你是如何解决Hadoop数据倾斜的问题的，能举个例子吗" class="headerlink" title="14.你是如何解决Hadoop数据倾斜的问题的，能举个例子吗?"></a>14.你是如何解决Hadoop数据倾斜的问题的，能举个例子吗?</h2><h5 id="1）提前在map进行combine，减少传输的数据量"><a href="#1）提前在map进行combine，减少传输的数据量" class="headerlink" title="1）提前在map进行combine，减少传输的数据量"></a>1）提前在map进行combine，减少传输的数据量</h5><p>在Mapper加上combiner相当于提前进行reduce，即把一个Mapper中的相同key进行了聚合，减少shuffle过程中传输的数据量，以及Reducer端的计算量。<br>如果导致数据倾斜的key 大量分布在不同的mapper的时候，这种方法就不是很有效了。</p>
<h5 id="2）数据倾斜的key-大量分布在不同的mapper"><a href="#2）数据倾斜的key-大量分布在不同的mapper" class="headerlink" title="2）数据倾斜的key 大量分布在不同的mapper"></a>2）数据倾斜的key 大量分布在不同的mapper</h5><ul>
<li><p>第一次在map阶段对那些导致了数据倾斜的key 加上1到n的随机前缀，这样本来相同的key 也会被分到多个Reducer 中进行局部聚合，数量就会大大降低。<br>第二次mapreduce，去掉key的随机前缀，进行全局聚合。<br>「思想」：二次mr，第一次将key随机散列到不同 reducer 进行处理达到负载均衡目的。第二次再根据去掉key的随机前缀，按原key进行reduce处理。<br>这个方法进行两次mapreduce，性能稍差</p>
</li>
<li><p>「增加Reducer，提升并行度」<br><code>JobConf.setNumReduceTasks(int)</code></p>
</li>
<li><p>「实现自定义分区」<br>根据数据分布情况，自定义散列函数，将key均匀分配到不同Reducer</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="ckxprkvpv0001fksofrj03610" data-title="hadoop面试题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础练习题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/20/Java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-12-20T05:53:03.000Z" itemprop="datePublished">2021-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/20/Java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/">Java基础练习题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-编写程序实现对给定的-4-个整数从大到小的顺序排列。"><a href="#1-编写程序实现对给定的-4-个整数从大到小的顺序排列。" class="headerlink" title="1.编写程序实现对给定的 4 个整数从大到小的顺序排列。"></a>1.编写程序实现对给定的 4 个整数从大到小的顺序排列。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;个数字&quot;</span>);</span><br><span class="line">        num[i] = scan.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minindex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt; num[i]) &#123;</span><br><span class="line">                minindex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = num[minindex];</span><br><span class="line">        num[minindex] = num[i];</span><br><span class="line">        num[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        System.out.print(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-编写程序求一元二次方程的根"><a href="#2-编写程序求一元二次方程的根" class="headerlink" title="2.编写程序求一元二次方程的根"></a>2.编写程序求一元二次方程的根</h2><h6 id="△-b-2-4ac的值-若△小于0-一元二次方程无根-若△等于0-一元二次方程有两个相等的根-若△大于0-一元二次方程有两个不相等的实数根"><a href="#△-b-2-4ac的值-若△小于0-一元二次方程无根-若△等于0-一元二次方程有两个相等的根-若△大于0-一元二次方程有两个不相等的实数根" class="headerlink" title="△=b^2-4ac的值,若△小于0,一元二次方程无根.若△等于0,一元二次方程有两个相等的根.若△大于0,一元二次方程有两个不相等的实数根"></a>△=b^2-4ac的值,若△小于0,一元二次方程无根.若△等于0,一元二次方程有两个相等的根.若△大于0,一元二次方程有两个不相等的实数根</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;2次项的系数:&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> a = scan.nextInt();</span><br><span class="line">    System.out.print(<span class="string">&quot;1次项的系数:&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> b = scan.nextInt();</span><br><span class="line">    System.out.print(<span class="string">&quot;0次项的系数:&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> c = scan.nextInt();</span><br><span class="line">    <span class="comment">//判断方程是否有根</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i = (b * b) - (<span class="number">4</span> * a * c);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> x1 = (-b + Math.sqrt(i)) / (<span class="number">2</span> * a);</span><br><span class="line">        <span class="keyword">double</span> x2 = (-b - Math.sqrt(i)) / (<span class="number">2</span> * a);</span><br><span class="line">        System.out.println(x1 + <span class="string">&quot;:&quot;</span> + x2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方程无解&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-编写程序，输入一个字符，判断它是否为小写字母，如果是，将它转换成大写字母，否则，不转换。"><a href="#3-编写程序，输入一个字符，判断它是否为小写字母，如果是，将它转换成大写字母，否则，不转换。" class="headerlink" title="3.编写程序，输入一个字符，判断它是否为小写字母，如果是，将它转换成大写字母，否则，不转换。"></a>3.编写程序，输入一个字符，判断它是否为小写字母，如果是，将它转换成大写字母，否则，不转换。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小写字母的ascll值为97-122</span></span><br><span class="line">    <span class="comment">//大写字母的ascll值为65-90</span></span><br><span class="line">    <span class="keyword">char</span> a = scan.next().charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= <span class="number">97</span> &amp;&amp; a &lt;= <span class="number">122</span>) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        a = (<span class="keyword">char</span>) (a - <span class="number">32</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非小写字母&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-输入-3-个正数，判断能否构成一个三角形。"><a href="#4-输入-3-个正数，判断能否构成一个三角形。" class="headerlink" title="4.输入 3 个正数，判断能否构成一个三角形。"></a>4.输入 3 个正数，判断能否构成一个三角形。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">worker4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span> c = scan.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可以构成三角形&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能构成三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-编写程序，对输入的年、月、日，给出该天是该年的第多少天？"><a href="#5-编写程序，对输入的年、月、日，给出该天是该年的第多少天？" class="headerlink" title="5.编写程序，对输入的年、月、日，给出该天是该年的第多少天？"></a>5.编写程序，对输入的年、月、日，给出该天是该年的第多少天？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">worker5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> monthDay[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> year = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span> month = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span> day = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; month - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">                days += <span class="number">29</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                days += <span class="number">28</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            days += monthDay[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    days = days + day;</span><br><span class="line">    System.out.println(<span class="string">&quot;今天是今年的第&quot;</span> + days + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-编写程序，从键盘输入一个-0-99999-之间的任意数，判断输入的数是几位数？"><a href="#6-编写程序，从键盘输入一个-0-99999-之间的任意数，判断输入的数是几位数？" class="headerlink" title="6.编写程序，从键盘输入一个 0~99999 之间的任意数，判断输入的数是几位数？"></a>6.编写程序，从键盘输入一个 0~99999 之间的任意数，判断输入的数是几位数？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">worker6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String num = scan.nextLine();</span><br><span class="line">    <span class="keyword">int</span> a = num.length();</span><br><span class="line">    System.out.println(a + <span class="string">&quot;位数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…持续更新中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/20/Java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/" data-id="ckxprkvpy0003fksoe6v89tuy" data-title="Java基础练习题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" rel="tag">java基础语法练习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Centos7安装Docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/20/Centos7%E5%AE%89%E8%A3%85Docker/" class="article-date">
  <time class="dt-published" datetime="2021-12-20T05:44:17.000Z" itemprop="datePublished">2021-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/20/Centos7%E5%AE%89%E8%A3%85Docker/">Centos7安装Docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-查看系统内核版本-gt-3-10"><a href="#1-查看系统内核版本-gt-3-10" class="headerlink" title="1.查看系统内核版本(&gt;3.10)"></a>1.查看系统内核版本(&gt;3.10)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<h3 id="2-更新yum，安装相应的yum包"><a href="#2-更新yum，安装相应的yum包" class="headerlink" title="2.更新yum，安装相应的yum包"></a>2.更新yum，安装相应的yum包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">卸载旧版本(如果之前安装过Docker)</span><br><span class="line">sudo yum remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>
<h3 id="3-设置docker-yum源"><a href="#3-设置docker-yum源" class="headerlink" title="3.设置docker yum源"></a>3.设置docker yum源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash">安装指定版本</span></span><br><span class="line">sudo yum install &lt;FQPN&gt; # 例如：sudo yum install docker-ce-17.12.0.ce</span><br></pre></td></tr></table></figure>
<h3 id="5-启动并加入开机启动"><a href="#5-启动并加入开机启动" class="headerlink" title="5.启动并加入开机启动"></a>5.启动并加入开机启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
<h3 id="6-验证安装是否成功-有client和service两部分表示docker安装启动都成功了"><a href="#6-验证安装是否成功-有client和service两部分表示docker安装启动都成功了" class="headerlink" title="6.验证安装是否成功(有client和service两部分表示docker安装启动都成功了)"></a>6.验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<img src="/2021/12/20/Centos7%E5%AE%89%E8%A3%85Docker/docker.png" class="" title="成功截图">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/20/Centos7%E5%AE%89%E8%A3%85Docker/" data-id="ckxprkvpr0000fkso2bm26hrz" data-title="Centos7安装Docker" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" rel="tag">java基础语法练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" style="font-size: 10px;">java基础语法练习</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 20px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E7%BB%8F%EF%BC%882021-11%E6%9C%88%EF%BC%89/">大数据面经（2021/11月）</a>
          </li>
        
          <li>
            <a href="/2021/12/20/hadoop%E9%9D%A2%E8%AF%95%E9%A2%98/">hadoop面试题</a>
          </li>
        
          <li>
            <a href="/2021/12/20/Java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/">Java基础练习题</a>
          </li>
        
          <li>
            <a href="/2021/12/20/Centos7%E5%AE%89%E8%A3%85Docker/">Centos7安装Docker</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>